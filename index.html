<!DOCTYPE html>
<html>
<head>
    <title>Clínica Crush</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0 0 50px 0; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #34495e;
            font-family: 'Verdana', sans-serif;
            color: white;
            flex-direction: column;
            overflow: hidden;
        }
        h1 {
            font-size: 3em;
            color: #ecf0f1;
            text-shadow: 3px 3px 5px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        #level-selection-screen {
            display: flex;
            gap: 30px;
            justify-content: center;
            align-items: stretch;
            padding: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        .level-card {
            background-color: #2c3e50;
            border: 4px solid #ecf0f1;
            border-radius: 15px;
            padding: 25px;
            width: 220px;
            text-align: center;
            box-shadow: 0 8px 15px rgba(0,0,0,0.4);
            transition: transform 0.2s;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .level-card:hover {
            transform: translateY(-10px);
        }
        .level-card h2 {
            font-size: 1.6em;
            margin-top: 0;
            color: #f1c40f;
        }
        .level-card p {
            font-size: 1em;
            margin-bottom: 20px;
        }
        .level-card .goals-list {
            margin-bottom: 25px;
        }
        .start-button {
            background-color: #2ecc71;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 20px;
        }
        .start-button:hover {
            background-color: #27ae60;
        }
        #game-container {
            border: 5px solid #ecf0f1;
            border-radius: 10px;
            padding: 10px;
            background-color: #2c3e50;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            display: none;
            gap: 20px;
            align-items: center;
            width: auto;
        }
        canvas {
            border-radius: 5px;
            display: block;
            cursor: pointer;
        }
        #ui-panel {
            width: 250px;
            padding: 20px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 10px;
            text-align: center;
        }
        #level-title { font-size: 1.5em; margin-bottom: 20px; text-shadow: 1px 1px 2px #000; }
        #moves-counter { font-size: 1.2em; margin-bottom: 30px; }
        #goals-container h3 { margin-bottom: 15px; border-bottom: 2px solid white; padding-bottom: 5px; }
        .goal { display: flex; align-items: center; justify-content: center; font-size: 1.1em; margin-bottom: 10px; }
        .goal-color { width: 20px; height: 35px; border-radius: 10px; margin-right: 15px; border: 2px solid white; }
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #modal-content {
            background-color: #34495e;
            padding: 30px;
            border-radius: 15px;
            border: 4px solid #ecf0f1;
            text-align: center;
            width: 90%;
            max-width: 500px;
        }
        #modal-content h2 { color: #f1c40f; }
        #modal-fact { font-size: 1.1em; margin: 20px 0; font-style: italic; color: #bdc3c7;}
        #modal-buttons { display: flex; justify-content: center; gap: 20px; margin-top: 20px; }
        .modal-button { padding: 12px 25px; font-size: 1em; border-radius: 8px; border: none; cursor: pointer; }
        #next-level-btn { background-color: #2ecc71; color: white; }
        #finish-btn { background-color: #e74c3c; color: white; }
        footer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background-color: #2c3e50;
            text-align: center;
            font-size: 0.9em;
            color: #ecf0f1;
            z-index: 1001;
        }
        @media (max-width: 850px) {
            body {
                overflow-y: auto;
                height: auto;
                min-height: 100vh;
                padding-top: 20px;
            }
            h1 {
                font-size: 2.5em;
            }
            #level-selection-screen,
            #game-container {
                flex-direction: column;
                height: auto;
                padding: 15px;
                gap: 15px;
            }
            .level-card {
                width: 80%;
                max-width: 350px;
                margin-bottom: 15px;
            }
            #ui-panel {
                width: 90%;
                max-width: 480px;
                margin-bottom: 15px;
            }
            #game-canvas {
                order: -1;
            }
        }
    </style>
</head>
<body>
    <h1>Clínica Crush</h1>
    <div id="level-selection-screen"></div>

    <div id="game-container">
        <div id="ui-panel">
            <h2 id="level-title"></h2>
            <div id="moves-counter"></div>
            <div id="goals-container">
                <h3>Metas</h3>
                <div id="goals-list"></div>
            </div>
        </div>
        <canvas id="game-canvas"></canvas>
    </div>

    <div id="modal-overlay">
        <div id="modal-content">
            <h2>Nível Concluído!</h2>
            <p id="modal-fact"></p>
            <div id="modal-buttons">
                <button id="finish-btn" class="modal-button">Finalizar</button>
                <button id="next-level-btn" class="modal-button">Próximo Nível</button>
            </div>
        </div>
    </div>

    <footer>
        &copy; 2025 Jonathan Albuquerque | Todos os direitos reservados
    </footer>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const levelSelectionScreen = document.getElementById('level-selection-screen');
        const gameContainer = document.getElementById('game-container');
        const levelTitleEl = document.getElementById('level-title');
        const movesCounterEl = document.getElementById('moves-counter');
        const goalsListEl = document.getElementById('goals-list');
        const modalOverlay = document.getElementById('modal-overlay');
        const modalFactEl = document.getElementById('modal-fact');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const finishBtn = document.getElementById('finish-btn');

        const COLS = 8;
        const ROWS = 8;
        let TILE_SIZE = 60;
        const PADDING = 10;
        const REMEDY_TYPES = 5;
        const COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6'];
        const REMEDY_NAMES = ['Analgésico', 'Antitérmico', 'Anti-inflamatório', 'Vitamina', 'Antibiótico'];
        const LEVELS = [
            { title: "Dor de Cabeça", moves: 20, goals: { 0: 15 }, fact: "Sabia que a dor de cabeça tensional, geralmente causada por estresse, é a mais comum? Analgésicos ajudam a bloquear os sinais de dor." },
            { title: "Controlar a Febre", moves: 25, goals: { 1: 20, 3: 10 }, fact: "A febre não é uma doença, mas uma defesa do corpo! A temperatura mais alta ajuda a combater vírus e bactérias." },
            { title: "Combater Infecção", moves: 30, goals: { 4: 15, 2: 15 }, fact: "Antibióticos só funcionam contra bactérias, não contra vírus (como os da gripe). Foram descobertos por acidente a partir de um mofo!" }
        ];

        let board = [], isAnimating = false, dragStartTile = null, isDragging = false, cursorPos = { x: 0, y: 0 };
        let dragStartPos = { x: 0, y: 0 };
        let currentLevelIndex = 0, movesLeft = 0, levelGoals = {};
        const DRAG_THRESHOLD = 10;
        
        const wait = (ms) => new Promise(res => setTimeout(res, ms));

        function resizeCanvas() {
            const screenWidth = window.innerWidth;
            let availableWidth;
            if (screenWidth <= 850) {
                availableWidth = screenWidth * 0.9;
            } else {
                const uiPanelWidth = 250;
                const gaps = 60;
                availableWidth = Math.min(screenWidth - uiPanelWidth - gaps, window.innerHeight * 0.8);
            }
            TILE_SIZE = Math.floor(availableWidth / COLS);
            
            // **FIX: Lógica para alta resolução (HiDPI / Retina)**
            const dpr = window.devicePixelRatio || 1;
            const logicalWidth = COLS * TILE_SIZE;
            const logicalHeight = ROWS * TILE_SIZE;

            canvas.width = logicalWidth * dpr;
            canvas.height = logicalHeight * dpr;

            canvas.style.width = `${logicalWidth}px`;
            canvas.style.height = `${logicalHeight}px`;

            ctx.scale(dpr, dpr);
            
            if (gameContainer.style.display === 'flex') {
                draw();
            }
        }

        function showLevelSelection() {
            gameContainer.style.display = 'none';
            document.querySelector('h1').style.display = 'block';
            levelSelectionScreen.style.display = 'flex';
            levelSelectionScreen.innerHTML = '';
            LEVELS.forEach((level, index) => {
                const card = document.createElement('div');
                card.className = 'level-card';
                let goalsHtml = '<div class="goals-list">';
                for(const type in level.goals) { goalsHtml += `<p>${level.goals[type]} x ${REMEDY_NAMES[type]}</p>`; }
                goalsHtml += '</div>';
                card.innerHTML = `<div><h2>${level.title}</h2><p>Movimentos: ${level.moves}</p>${goalsHtml}</div><button class="start-button" data-level="${index}">Começar Jogo</button>`;
                levelSelectionScreen.appendChild(card);
            });
            document.querySelectorAll('.start-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const levelIndex = parseInt(e.target.getAttribute('data-level'));
                    startGame(levelIndex);
                });
            });
        }

        function startGame(levelIndex) {
            levelSelectionScreen.style.display = 'none';
            document.querySelector('h1').style.display = 'none';
            gameContainer.style.display = 'flex';
            startLevel(levelIndex);
            resizeCanvas(); 
        }

        function startLevel(levelIndex) {
            currentLevelIndex = levelIndex;
            const level = LEVELS[levelIndex];
            if (!level) {
                modalFactEl.innerHTML = "<strong>Parabéns!</strong><br>Você completou todos os desafios com sucesso.";
                nextLevelBtn.style.display = 'none';
                modalOverlay.style.display = 'flex';
                return;
            }
            movesLeft = level.moves;
            levelGoals = JSON.parse(JSON.stringify(level.goals));
            initBoard();
            updateUI();
        }

        function updateUI() {
            const level = LEVELS[currentLevelIndex];
            levelTitleEl.textContent = level.title;
            movesCounterEl.innerHTML = `Movimentos: <strong>${movesLeft}</strong>`;
            goalsListEl.innerHTML = "";
            for (const type in level.goals) {
                const remaining = levelGoals[type];
                const goalEl = document.createElement('div');
                goalEl.className = 'goal';
                goalEl.innerHTML = `<div class="goal-color" style="background: linear-gradient(to bottom, ${COLORS[type]} 50%, #ffffff 50%)"></div><span>${REMEDY_NAMES[type]}: ${remaining > 0 ? remaining : 0}</span>`;
                goalsListEl.appendChild(goalEl);
            }
        }

        function initBoard() {
            board = [];
            for (let y = 0; y < ROWS; y++) {
                board[y] = [];
                for (let x = 0; x < COLS; x++) {
                    board[y][x] = { type: Math.floor(Math.random() * REMEDY_TYPES) };
                }
            }
            while (findMatches().length > 0) {
                removeMatches(findMatches(), false);
                fillBoard();
            }
        }

        function removeMatches(matches, shouldTrackGoal = true) {
            if (matches.length > 0) {
                matches.forEach(match => {
                    if (shouldTrackGoal && board[match.y][match.x]) {
                        const type = board[match.y][match.x].type;
                        if (levelGoals[type] !== undefined) {
                            levelGoals[type]--;
                        }
                    }
                    board[match.y][match.x] = null;
                });
                updateUI();
                return true;
            }
            return false;
        }

        async function gameLoop() {
            isAnimating = true;
            let matches = findMatches();
            while (matches.length > 0) {
                await animateMatches(matches);
                removeMatches(matches);
                await animateDrop();
                await wait(100);
                fillBoard();
                draw();
                await wait(200);
                matches = findMatches();
            }
            isAnimating = false;
            checkWinCondition();
        }

        function checkWinCondition() {
            let goalsMet = true;
            for (const type in levelGoals) {
                if (levelGoals[type] > 0) {
                    goalsMet = false;
                    break;
                }
            }
            if (goalsMet) {
                showWinModal();
            } else if (movesLeft <= 0) {
                alert("Fim dos movimentos! Tente novamente.");
                showLevelSelection();
            }
        }
        
        function showWinModal() {
            const level = LEVELS[currentLevelIndex];
            modalFactEl.textContent = level.fact;
            if (LEVELS[currentLevelIndex + 1]) {
                nextLevelBtn.style.display = 'inline-block';
            } else {
                nextLevelBtn.style.display = 'none';
            }
            modalOverlay.style.display = 'flex';
        }

        function hideModal() {
            modalOverlay.style.display = 'none';
        }

        nextLevelBtn.addEventListener('click', () => { hideModal(); startGame(currentLevelIndex + 1); });
        finishBtn.addEventListener('click', () => { hideModal(); showLevelSelection(); });

        async function handleSwap(tile1, tile2) {
            const temp = board[tile1.y][tile1.x];
            board[tile1.y][tile1.x] = board[tile2.y][tile2.x];
            board[tile2.y][tile2.x] = temp;
            if (findMatches().length > 0) {
                movesLeft--;
                updateUI();
                await gameLoop();
            } else {
                await wait(200);
                const temp = board[tile1.y][tile1.x];
                board[tile1.y][tile1.x] = board[tile2.y][tile2.x];
                board[tile2.y][tile2.x] = temp;
            }
        }
        
        async function animateMatches(matches) { isAnimating = true; let scale = 1.0; const animationSpeed = 0.08; while (scale > 0) { scale -= animationSpeed; if (scale < 0) scale = 0; draw(); matches.forEach(match => { const tile = board[match.y][match.x]; if (tile) { drawPillAtPixels(match.x * TILE_SIZE, match.y * TILE_SIZE, tile.type, scale); } }); await wait(10); } }
        async function animateDrop() { isAnimating = true; let somethingDropped; do { somethingDropped = false; for (let x = 0; x < COLS; x++) { for (let y = ROWS - 2; y >= 0; y--) { if (board[y][x] && !board[y + 1][x]) { board[y + 1][x] = board[y][x]; board[y][x] = null; somethingDropped = true; } } } if (somethingDropped) { draw(); await wait(80); } } while (somethingDropped); isAnimating = false; }
        
        function drawPillAtPixels(pixelX, pixelY, type, scale = 1) {
            const pillWidth = (TILE_SIZE / 2) * scale;
            const pillHeight = (TILE_SIZE - PADDING) * scale;
            const radius = pillWidth / 2;
            if (radius <= 0) return;
            const drawX = pixelX + (TILE_SIZE - pillWidth) / 2;
            const drawY = pixelY + (TILE_SIZE - pillHeight) / 2;
            const middleY = drawY + pillHeight / 2;
            ctx.fillStyle = COLORS[type];
            ctx.fillRect(drawX, drawY + radius, pillWidth, (pillHeight / 2) - radius);
            ctx.beginPath();
            ctx.arc(drawX + radius, drawY + radius, radius, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(drawX, middleY, pillWidth, (pillHeight / 2) - radius);
            ctx.beginPath();
            ctx.arc(drawX + radius, middleY + (pillHeight / 2) - radius, radius, 0, Math.PI);
            ctx.fill();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.ellipse(drawX + radius, drawY + pillHeight * 0.25, pillWidth * 0.3, pillHeight * 0.15, 0, 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawPill(x, y, type, scale = 1) {
            drawPillAtPixels(x * TILE_SIZE, y * TILE_SIZE, type, scale);
        }

        function draw() {
            const logicalWidth = COLS * TILE_SIZE;
            const logicalHeight = ROWS * TILE_SIZE;
            ctx.clearRect(0, 0, logicalWidth, logicalHeight);
            let targetTile = null;
            let dragDirection = null;
            let deltaX = 0, deltaY = 0;
            if (isDragging && dragStartTile) {
                const startPixelX = dragStartTile.x * TILE_SIZE + TILE_SIZE / 2;
                const startPixelY = dragStartTile.y * TILE_SIZE + TILE_SIZE / 2;
                deltaX = cursorPos.x - startPixelX;
                deltaY = cursorPos.y - startPixelY;
                if (Math.abs(deltaX) > DRAG_THRESHOLD || Math.abs(deltaY) > DRAG_THRESHOLD) {
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        dragDirection = 'horizontal';
                    } else {
                        dragDirection = 'vertical';
                    }
                }
                if (dragDirection) {
                    const directionX = deltaX > 0 ? 1 : (deltaX < 0 ? -1 : 0);
                    const directionY = deltaY > 0 ? 1 : (deltaY < 0 ? -1 : 0);
                    const targetX = dragStartTile.x + (dragDirection === 'horizontal' ? directionX : 0);
                    const targetY = dragStartTile.y + (dragDirection === 'vertical' ? directionY : 0);
                    if (targetX >= 0 && targetX < COLS && targetY >= 0 && targetY < ROWS) {
                        targetTile = { x: targetX, y: targetY };
                    }
                }
            }
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (isDragging && dragStartTile && x === dragStartTile.x && y === dragStartTile.y) continue;
                    if (isDragging && targetTile && x === targetTile.x && y === targetTile.y) continue;
                    if (board[y] && board[y][x]) {
                        drawPill(x, y, board[y][x].type);
                    }
                }
            }
            if (isDragging && dragStartTile) {
                const draggedPillData = board[dragStartTile.y][dragStartTile.x];
                if (!draggedPillData) return;
                if (dragDirection && targetTile) {
                    let visualDeltaX = deltaX, visualDeltaY = deltaY;
                    if (dragDirection === 'horizontal') {
                        visualDeltaY = 0;
                        visualDeltaX = Math.max(-TILE_SIZE, Math.min(TILE_SIZE, visualDeltaX));
                    } else {
                        visualDeltaX = 0;
                        visualDeltaY = Math.max(-TILE_SIZE, Math.min(TILE_SIZE, visualDeltaY));
                    }
                    const targetPillData = board[targetTile.y][targetTile.x];
                    if (targetPillData) {
                        drawPillAtPixels(targetTile.x * TILE_SIZE - visualDeltaX, targetTile.y * TILE_SIZE - visualDeltaY, targetPillData.type);
                    }
                    drawPillAtPixels(dragStartTile.x * TILE_SIZE + visualDeltaX, dragStartTile.y * TILE_SIZE + visualDeltaY, draggedPillData.type, 1.1);
                } else {
                    drawPillAtPixels(cursorPos.x - TILE_SIZE / 2, cursorPos.y - TILE_SIZE / 2, draggedPillData.type, 1.1);
                }
            }
        }
        function findMatches() { let matches = []; for (let y = 0; y < ROWS; y++) { for (let x = 0; x < COLS - 2; x++) { if (board[y][x] && board[y][x + 1] && board[y][x + 2] && board[y][x].type === board[y][x + 1].type && board[y][x + 1].type === board[y][x + 2].type) { matches.push({ x: x, y: y }, { x: x + 1, y: y }, { x: x + 2, y: y }); } } } for (let x = 0; x < COLS; x++) { for (let y = 0; y < ROWS - 2; y++) { if (board[y][x] && board[y + 1][x] && board[y + 2][x] && board[y][x].type === board[y + 1][x].type && board[y + 1][x].type === board[y + 2][x].type) { matches.push({ x: x, y: y }, { x: x, y: y + 1 }, { x: x, y: y + 2 }); } } } return [...new Set(matches.map(m => `${m.x},${m.y}`))].map(s => { const [x, y] = s.split(','); return { x: parseInt(x), y: parseInt(y) }; }); }
        function fillBoard() { for (let y = 0; y < ROWS; y++) { for (let x = 0; x < COLS; x++) { if (board[y][x] === null) { board[y][x] = { type: Math.floor(Math.random() * REMEDY_TYPES) }; } } } }
        function getTileAt(clientX, clientY) { const rect = canvas.getBoundingClientRect(); const x = clientX - rect.left; const y = clientY - rect.top; if (x < 0 || x >= canvas.width / (window.devicePixelRatio || 1) || y < 0 || y >= canvas.height / (window.devicePixelRatio || 1)) return null; return { x: Math.floor(x / TILE_SIZE), y: Math.floor(y / TILE_SIZE) }; }
        function updateCursorPos(e) { const rect = canvas.getBoundingClientRect(); const dpr = window.devicePixelRatio || 1; cursorPos.x = (e.clientX - rect.left); cursorPos.y = (e.clientY - rect.top); }
        
        function onDragStart(e) {
            if (isAnimating) return;
            dragStartTile = getTileAt(e.clientX, e.clientY);
            if (dragStartTile) {
                isDragging = true;
                updateCursorPos(e);
                dragStartPos.x = cursorPos.x;
                dragStartPos.y = cursorPos.y;
                draw();
            }
        }
        
        function onDragMove(e) {
            if (!isDragging) return;
            updateCursorPos(e);
            draw();
        }

        async function onDragEnd(e) {
            if (isAnimating || !isDragging) return;
            isDragging = false;
            
            if (dragStartTile) {
                updateCursorPos(e);
                const deltaX = cursorPos.x - dragStartPos.x;
                const deltaY = cursorPos.y - dragStartPos.y;

                if (Math.abs(deltaX) > DRAG_THRESHOLD || Math.abs(deltaY) > DRAG_THRESHOLD) {
                    let targetX = dragStartTile.x;
                    let targetY = dragStartTile.y;
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        targetX += (deltaX > 0) ? 1 : -1;
                    } else {
                        targetY += (deltaY > 0) ? 1 : -1;
                    }
                    if (targetX >= 0 && targetX < COLS && targetY >= 0 && targetY < ROWS) {
                        const targetTile = { x: targetX, y: targetY };
                        await handleSwap(dragStartTile, targetTile);
                    }
                }
            }
            dragStartTile = null;
            draw();
        }

        canvas.addEventListener('mousedown', (e) => onDragStart(e));
        canvas.addEventListener('mousemove', (e) => onDragMove(e));
        canvas.addEventListener('mouseup', (e) => onDragEnd(e));
        canvas.addEventListener('mouseleave', (e) => onDragEnd(e));
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); onDragStart(e.touches[0]); });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); onDragMove(e.touches[0]); });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); onDragEnd(e.changedTouches[0]); });
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', resizeCanvas);

        showLevelSelection();

    </script>
</body>
</html>
